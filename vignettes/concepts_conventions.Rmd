---
title: "Programming Concepts and Conventions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Admiral Programming Concepts and Conventions}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(admiraldev)
```

# Introduction

This vignette aims to discuss some of the common programming concepts and conventions that have been adopted within the
`{admiral}` family of packages. It is intended to be a user-facing version of the [Programming Strategy](https://pharmaverse.github.io/admiraldev/articles/programming_strategy.html) page, but users can also read the
latter after becoming more familiar with the package to expand further on any topics of interest. For some of common
`{admiral}` FAQ, visit the corresponding [FAQ page](faq.html).

# `{admiral}` Functions and Options

As a general principle, the behavior of the `{admiral}` functions is only determined by their input, not by any global object,
i.e. all inputs like datasets, variable names, options, etc. must be provided to the function by arguments. Correspondingly, the
functions do not have any side-effects like creating or modifying global objects, printing, writing files, etc.

An exception to the above principle is found in our approach to package options (see `get_admiral_option()` and `set_admiral_options()`),
which allow for user-defined defaults on commonly used function 
arguments. For instance, the option `subject_keys` is currently pre-defined as `exprs(STUDYID, USUBJID)`, but can be modified
using `set_admiral_options(subject_keys = exprs(...))` at the top of a script.

For a full discussion on admiral Inputs, Outputs and Options, see [this section](https://pharmaverse.github.io/admiraldev/articles/programming_strategy.html#input-output-and-side-effects) on our
developer-facing Programming Strategy.

# Handling of Missing Values

When using the `{haven}` package to read SAS datasets into R, SAS-style character missing values, i.e. `""`, are *not* 
converted into proper R `NA` values. Rather they are kept as is. This is problematic for any downstream data processing 
as R handles `""` just as any other string. Thus, before any data manipulation is being performed SAS blanks should be 
converted to R `NA`s using `{admiral}`'s `convert_blanks_to_na()` function, e.g.

```r
dm <- haven::read_sas("dm.sas7bdat") %>% 
  convert_blanks_to_na()
```

Note that any logical operator being applied to an `NA` value *always* returns `NA` rather than `TRUE` or `FALSE`.

```{r}
visits <- c("Baseline", NA, "Screening", "Week 1 Day 7")
visits != "Baseline"
```

The only exception is `is.na()` which returns `TRUE` if the input is `NA`.

```{r}
is.na(visits)
```

Thus, to filter all visits which are not `"Baseline"` the following condition would need to be used.

```{r}
visits != "Baseline" | is.na(visits)
```

Also note that most aggregation functions, like `mean()` or `max()`, also return `NA` if any element of the input vector is missing.

```{r}
mean(c(1, NA, 2))
```

To avoid this behavior one has to explicitly set `na.rm = TRUE`.

```{r}
mean(c(1, NA, 2), na.rm = TRUE)
```

This is very important to keep in mind when using `{admiral}`'s aggregation functions such as `derive_summary_records()`.

For handling of `NA`s in sorting variables see [Sort Order](generic.html#sort_order).

# Argument Conventions

Within the `{admiral}` package, any arguments which expect variable names or expressions of variable names, symbols or 
expressions must be specified rather than strings.

- For arguments which expect a single variable name, the name can be specified without quotes and quotation, e.g.
`new_var = TEMPBL`

- For arguments which expect one or more variable names, a list of symbols is expected, e.g. `by_vars = exprs(PARAMCD, AVISIT)` 

- For arguments which expect a single expression, the expression needs to be passed "as is", e.g. `filter = PARAMCD == "TEMP"`

- For arguments which expect one or more expressions, a list of expressions is expected, e.g. `order = exprs(AVISIT, desc(AESEV))`

If you are new to expressions, read the [corresponding section](#exprs) to learn more.

# `exprs()` {#exprs}

## What is `exprs()`?

`exprs()` is a function from the `{rlang}` package. It is used to create a list of expressions. The expressions are not evaluated 
- rather, they are passed on to the derivation function which evaluates them in its own environment. This allows the derivation 
function to evaluate the expressions in the context of the input dataset. Specifically, the `exprs()` function allows users to pass
variable names of datasets to the function without wrapping them in quotation marks. 

The expressions/`exprs()` framework is powerful because users are able to intuitively "inject code" into `admiral` functions
(through the function parameters) using very similar syntax as if they were writing open code, with the exception possibly being an
outer `exprs()` wrapper.  For instance, in the `derive_vars_merged()` call below, the user is merging `adsl` with `ex` and is able
to filter `ex` prior to the merge using an expression passed to the `filter_add` parameter. Because `filter_add` accepts expressions, 
the user has full power to filter their dataset as they please. In the same vein, the user is able to create any new variables they 
wish after the merge using the `new_vars` argument, to which they pass a list of expressions containing "standard" R code.

``` {r, eval = FALSE}
derive_vars_merged(
  adsl,
  dataset_add = ex,
  filter_add = !is.na(EXENDTM),
  by_vars = exprs(STUDYID, USUBJID),
  new_vars = exprs(
    TRTEDTM = EXENDTM,
    TRTETMF = EXENTMF,
    COMPTRT = if_else(!is.na(EXENDTM), "Y", "N")
  ),
  order = exprs(EXENDTM),
  mode = "last"
)
```

In summary, although expressions/`exprs()` may seem slightly clunky and unintuitive to begin with, they allow for such power
and flexibility that they are a key part of the `{admiral}` package. For a comprehensive treatment of expressions, see 
[Chapter 18](https://adv-r.hadley.nz/expressions.html) of the Advanced R textbook.

## Common pitfalls 

Expressions are very powerful, but this can also lead to misunderstandings about their functionality. Let's set up some dummy
data to explore common issues that new (or experienced!) programmers may encounter when dealing with expressions.

```{r, eval = TRUE, echo = TRUE}
library(dplyr, warn.conflicts = FALSE)
library(admiral)

vs <- tribble(
  ~USUBJID, ~VSTESTCD, ~VISIT, ~VSSTRESN, ~VSSTRESU, ~VSDTC,
  "01-1301", "WEIGHT", "SCREENING", 82.1, "kg", "2013-08-29",
  "01-1301", "WEIGHT", "WEEK 2", 81.19, "kg", "2013-09-15",
  "01-1301", "WEIGHT", "WEEK 4", 82.56, "kg", "2013-09-24",
  "01-1302", "BMI", "SCREENING", 20.1, "kg/m2", "2013-08-29",
  "01-1302", "BMI", "WEEK 2", 20.2, "kg/m2", "2013-09-15",
  "01-1302", "BMI", "WEEK 4", 19.9, "kg/m2", "2013-09-24"
)

dm <- tribble(
  ~USUBJID, ~AGE,
  "01-1301", 18
)
```

### 1. Mistakenly passing something that isn't an expression to an argument

When writing more complex `{admiral}` code it can be easy to mistakenly pass the wrong input to an argument that 
expects an expression. For example, the code below fails because `my_expression` is not an expression - is 
the name of an object in the global environment containing an expression.

```{r, eval = TRUE, error = TRUE}
my_expression <- expr(VSTESTCD == "WEIGHT" & VISIT == "SCREENING")

derive_vars_merged(
  dm,
  dataset_add = select(vs, USUBJID, VSTESTCD, VISIT),
  by_vars = exprs(USUBJID),
  filter_add = my_expression
)
```

To fix this code, we need to [unquote](https://adv-r.hadley.nz/quasiquotation.html#quasi-motivation) `my_expression` so 
that the expression that it is holding is passed correctly to `derive_vars_merged()`:

```{r, eval = TRUE, error = FALSE}
derive_vars_merged(
  dm,
  dataset_add = select(vs, USUBJID, VSTESTCD, VISIT),
  by_vars = exprs(USUBJID),
  filter_add = !!my_expression
)
```

### 2. Forgetting that expressions must be evaluable in the dataset

In a similar vein to above, even if an actual expression *is* passed as an argument, you must make
sure that it can be evaluated within the dataset of interest. For instance, consider this code:

```{r, eval = TRUE, error = TRUE}
merge_weight_or_bmi <- function(weight_or_bmi) {
  if (weight_or_bmi == "WEIGHT") {
    my_wt_bmi_expression <- 'VSTESTCD == "WEIGHT" & VISIT == "SCREENING"'
  } else {
    my_wt_bmi_expression <- 'VSTESTCD == "BMI" & VISIT == "SCREENING"'
  }

  derive_vars_merged(
    dm,
    dataset_add = select(vs, USUBJID, VSTESTCD, VISIT),
    by_vars = exprs(USUBJID),
    filter_add = eval(parse(text = my_wt_bmi_expression))
  )
}

merge_weight_or_bmi("BMI")
```

This fails because the expression is:

```{r, eval = TRUE}
expr(eval(parse(text = my_fn_condition)))
```

and contains `my_fn_condition`, which is not in the dataset.

Conversely, this works:

```{r, eval = TRUE}
merge_weight_or_bmi <- function(weight_or_bmi) {
  if (weight_or_bmi == "WEIGHT") {
    my_wt_bmi_expression <- expr(VSTESTCD == "WEIGHT" & VISIT == "SCREENING")
  } else {
    my_wt_bmi_expression <- expr(VSTESTCD == "WEIGHT" & VISIT == "SCREENING")
  }

  derive_vars_merged(
    dm,
    dataset_add = select(vs, USUBJID, VSTESTCD, VISIT),
    by_vars = exprs(USUBJID),
    filter_add = !!my_wt_bmi_expression
  )
}

merge_weight_or_bmi("BMI")
```

because the expression being passed to `derive_vars_merged()` is:

```{r, eval = TRUE}
expr(!!expr(VSTESTCD == "WEIGHT" & VISIT == "SCREENING"))
```

# See also

- [Programming Strategy](https://pharmaverse.github.io/admiraldev/articles/programming_strategy.html)
